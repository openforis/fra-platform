import * as pgPromise from 'pg-promise'
import { Promises } from 'utils/promises'

import { AssessmentController } from 'server/controller/assessment'
import { BaseProtocol, Schemas } from 'server/db'
import { getCreateSchemaCycleOriginalDataPointViewDDL } from 'server/repository/assessment/assessment/getCreateSchemaDDL'

const alterTable = (_: TemplateStringsArray, schemaName: string) => {
  return `alter table if exists ${schemaName}.node_ext rename to node_ext_old;`
}

const createTable = (_: TemplateStringsArray, schemaName: string) => {
  return `
      create table ${schemaName}.node_ext
      (
          id bigint generated by default as identity,
          uuid uuid not null default uuid_generate_v4(),
          country_iso varchar(3) references country(country_iso) not null,
          type varchar(255) not null,
          props jsonb default '{}'::jsonb,
          primary key (id)
      );
    
      
      -- add index 1
      create index node_ext_country_iso_idx on ${schemaName}.node_ext (country_iso);
      
      -- add index 2
      create index node_ext_uuid_idx on ${schemaName}.node_ext (uuid);
  `
}

const migrateOldData = (_: TemplateStringsArray, schemaName: string) => {
  return `
      insert into ${schemaName}.node_ext (country_iso, type, props)
      select
        country_iso,
        'node_ext',
        jsonb_build_object('tableName', table_name, 'variableName', variable_name, 'colName', col_name, 'value', value)
      from ${schemaName}.node_ext_old;
    `
}

// -- only update if not already updated
const wrapWithIf = (schemaName: string, queries: string) => {
  return `
    do $$
    begin
        if exists(SELECT *
                  FROM information_schema.columns
                  WHERE table_name='node_ext' and table_schema='${schemaName}' and column_name='variable_name')
        then
           ${queries}
        end if;
    end $$;`
}

export default async (client: BaseProtocol) => {
  const pgp = pgPromise()
  const assessments = await AssessmentController.getAll({}, client)

  await Promises.each(assessments, async (assessment) => {
    return Promises.each(assessment.cycles, async (cycle) => {
      const schemaCycle = Schemas.getNameCycle(assessment, cycle)
      const queries = `${pgp.helpers.concat([
        alterTable`${schemaCycle}`,
        createTable`${schemaCycle}`,
        migrateOldData`${schemaCycle}`,
      ])};
      ${getCreateSchemaCycleOriginalDataPointViewDDL(schemaCycle)}`

      const query = wrapWithIf(schemaCycle, queries)

      await client.query(query)
    })
  })
}
